NullPointerExceptions O
are O
exceptions O
that O
occur O
when O
you O
try O
to O
use O
a O
reference O
that O
points O
to O
no O
location O
in O
memory O
( O
null O
) O
as O
though O
it O
were O
referencing O
an O
object O
. O

Calling O
a O
method O
on O
a O
null O
reference O
or O
trying O
to O
access O
a O
field O
of O
a O
null O
reference O
will O
trigger O
a O
NullPointerException O
. O

These O
are O
the O
most O
common O
, O
but O
other O
ways O
are O
listed O
on O
the O
NullPointerException O
javadoc O
page O
. O

Probably O
the O
quickest O
example O
code O
I O
could O
come O
up O
with O
to O
illustrate O
a O
NullPointerException O
would O
be O
: O
Object.hashCode O

On O
the O
first O
line O
inside O
main O

I'm O
explicitly O
setting O
the O
Object O
reference O
obj O
equal O
to O
null O
. O

This O
means O
I O
have O
a O
reference O
, O
but O
it O
isn't O
pointing O
to O
any O
object O
. O

After O
that O
, O
I O
try O
to O
treat O
the O
reference O
as O
though O
it O
points O
to O
an O
object O
by O
calling O
a O
method O
on O
it O
. O

This O
results O
in O
a O
NullPointerException O
because O
there O
is O
no O
code O
to O
execute O
in O
the O
location O
that O
the O
reference O
is O
pointing O
. O

( O
This O
is O
a O
technicality O
, O
but O
I O
think O
it O
bears O
mentioning O
: O
A O
reference O
that O
points O
to O
null O
isn't O
the O
same O
as O
a O
C O
pointer O
that O
points O
to O
an O
invalid O
memory O
location O
. O

A O
null O
pointer O
is O
literally O
not O
pointing O
anywhere O
, O
which O
is O
subtly O
different O
than O
pointing O
to O
a O
location O
that O
happens O
to O
be O
invalid O
. O
) O

A O
null O
pointer O
exception O
is O
caused O
when O
you O
dereference O
a O
variable O
that O
is O
pointing O
to O
null O
. O

See O
the O
following O
code O
: O
String.toString O
NullPointerException O
will O
be O
thrown O

A O
NULL O
pointer O
is O
one O
that O
points O
to O
nowhere O
. O

When O
you O
dereference O
a O
pointer O
p O
, O
you O
say O
" O
give O
me O
the O
data O
at O
the O
location O
stored O
in O
" O
p O
" O
. O

When O
p O
is O
a O
null O
pointer O
, O
the O
location O
stored O
in O
p O
is O
nowhere O
, O
you're O
saying O
" O
give O
me O
the O
data O
at O
the O
location O
' O
nowhere O
'" O
. O

Obviously O
it O
can't O
do O
this O
, O
so O
it O
throws O
a O
NULL O
pointer O
exception O
. O

In O
general O
, O
it's O
because O
something O
hasn't O
been O
initialized O
properly O
. O

When O
you O
declare O
a O
reference O
variable O
( O
i.e. O
an O
object O
) O
you O
are O
really O
creating O
a O
pointer O
to O
an O
object O
. O

Consider O
the O
following O
code O
where O
you O
declare O
a O
variable O
of O
primitive O
type O
int O
: O

In O
this O
example O
the O
variable O
x O
is O
an O
int O
and O
Java O
will O
initialize O
it O
to O
0 O
for O
you O
. O

When O
you O
assign O
it O
to O
10 O
in O
the O
second O
line O
your O
value O
10 O
is O
written O
into O
the O
memory O
location O
pointed O
to O
by O
x O
. O

But O
, O
when O
you O
try O
to O
declare O
a O
reference O
type O
something O
different O
happens O
. O

Take O
the O
following O
code O
: O
Integer O
The O
first O
line O
declares O
a O
variable O
named O
num O
, O
but O
, O
it O
does O
not O
contain O
a O
primitive O
value O
. O

Instead O
it O
contains O
a O
pointer O
( O
because O
the O
type O
is O
Integer O
which O
is O
a O
reference O
type O
) O
. O

Since O
you O
did O
not O
say O
as O
yet O
what O
to O
point O
to O
Java O
sets O
it O
to O
null O
, O
meaning O
" O
I O
am O
pointing O
at O
nothing O
" O
. O

In O
the O
second O
line O
, O
the O
new O
keyword O
is O
used O
to O
instantiate O
( O
or O
create O
) O
an O
object O
of O
type O
Integer O
and O
the O
pointer O
variable O
num O
is O
assigned O
this O
object O
. O

You O
can O
now O
reference O
the O
object O
using O
the O
dereferencing O
operator O
. O

( O
a O
dot O
) O
. O

The O
Exception O
that O
you O
asked O
about O
occurs O
when O
you O
declare O
a O
variable O
but O
did O
not O
create O
an O
object O
. O

If O
you O
attempt O
to O
dereference O
num O
BEFORE O
creating O
the O
object O
you O
get O
a O
NullPointerException O
. O

In O
the O
most O
trivial O
cases O
the O
compiler O
will O
catch O
the O
problem O
and O
let O
you O
know O
that O
" O
num O
may O
not O
have O
been O
initialized O
" O
but O
sometimes O
you O
write O
code O
that O
does O
not O
directly O
create O
the O
object O
. O

For O
instance O
you O
may O
have O
a O
method O
as O
follows O
: O
do O
something O
to O
obj O
in O
which O
case O
you O
are O
not O
creating O
the O
object O
obj O
, O
rather O
assuming O
that O
is O
was O
created O
before O
the O
doSomething O
method O
was O
called O
. O

Unfortunately O
it O
is O
possible O
to O
call O
the O
method O
like O
this O
: O
in O
which O
case O
obj O
is O
null O
. O

If O
the O
method O
is O
intended O
to O
do O
something O
to O
the O
passed-in O
object O
, O
it O
is O
appropriate O
to O
throw O
the O
NullPointerException O
because O
it's O
a O
programmer O
error O
and O
the O
programmer O
will O
need O
that O
information O
for O
debugging O
purposes O
. O

Alternatively O
, O
there O
may O
be O
cases O
where O
the O
purpose O
of O
the O
method O
is O
not O
solely O
to O
operate O
on O
the O
passed O
in O
object O
, O
and O
therefore O
a O
null O
parameter O
may O
be O
acceptable O
. O

In O
this O
case O
, O
you O
would O
need O
to O
check O
for O
a O
null O
parameter O
and O
behave O
differently O
. O

You O
should O
also O
explain O
this O
in O
the O
documentation O
. O

For O
example O
, O
doSomething O
could O
be O
written O
as O
: O
do O
something O
do O
something O
else O
Finally O
, O
How O
to O
pinpoint O
the O
exception O
location O
& O
cause O
using O
Stack O
Trace O

In O
Java O
all O
the O
variables O
you O
declare O
are O
actually O
" O
references O
" O
to O
the O
objects O
( O
or O
primitives O
) O
and O
not O
the O
objects O
themselves O
. O

When O
you O
attempt O
to O
execute O
one O
object O
method O
, O
the O
reference O
ask O
the O
living O
object O
to O
execute O
that O
method O
. O

But O
if O
the O
reference O
is O
referencing O
NULL O
( O
nothing O
, O
zero O
, O
void O
, O
nada O
) O
then O
there O
is O
no O
way O
the O
method O
gets O
executed O
. O

Then O
the O
runtime O
let O
you O
know O
this O
by O
throwing O
a O
NullPointerException O
. O

Your O
reference O
is O
" O
pointing O
" O
to O
null O
, O
thus O
" O
Null O
-> O
Pointer O
" O
. O

The O
object O
lives O
in O
the O
VM O
memory O
space O
and O
the O
only O
way O
to O
access O
it O
is O
using O
this O
references O
. O

Take O
this O
example O
: O
This O
an O
important O
thing O
to O
know O
- O
when O
there O
are O
no O
more O
references O
to O
an O
object O
( O
in O
the O
example O
above O
when O
" O
reference O
" O
and O
" O
otherReference O
" O
point O
to O
null O
) O
then O
the O
object O
is O
" O
unreachable O
" O
. O

There O
is O
no O
way O
we O
can O
work O
with O
it O
, O
so O
this O
object O
is O
marked O
for O
to O
be O
garbage O
collected O
, O
and O
at O
some O
point O
the O
VM O
will O
free O
the O
memory O
used O
by O
this O
object O
and O
will O
allocate O
another O
. O

In O
Java O
every O
things O
is O
in O
the O
form O
of O
class O
. O

If O
you O
want O
to O
use O
any O
object O
then O
you O
have O
two O
phases O

Declare O
Initialization O
Example O

: O
Declaration O
: O
int O
a O
; O
initialization O
: O
a=0 O
; O
Same O
for O
Array O
concept O
Declaration O
: O

Item O
i[ O
]= O
new O
Item[5 O
]; O
Initialization O
: O
i[0 O
]= O
new O
Item() O
; O
If O
you O
not O
given O
Initialization O
section O
then O
the O
NullpointerException O
arise O
. O

Null O
pointer O
exception O
is O
thrown O
when O
an O
application O
attempts O
to O
use O
null O
in O
a O
case O
where O
an O
object O
is O
required O
. O

These O
include O
: O
Calling O
the O
instance O
method O
of O
a O
null O
object O
. O

Accessing O
or O
modifying O
the O
field O
of O
a O
null O
object O
. O

Taking O
the O
length O
of O
null O
as O
if O
it O
were O
an O
array O
. O

Accessing O
or O
modifying O
the O
slots O
of O
null O
as O
if O
it O
were O
an O
array O
. O

Throwing O
null O
as O
if O
it O
were O
a O
Throwable O
value O
. O

Applications O
should O
throw O
instances O
of O
this O
class O
to O
indicate O
other O
illegal O
uses O
of O
the O
null O
object O
. O

Reference O
: O
http://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html O

A O
null O
pointer O
exception O
is O
an O
indicator O
that O
you O
are O
using O
Object O
without O
initialize O
it O
. O

e.g O
below O
is O
a O
student O
class O
which O
will O
use O
in O
our O
code O
. O

below O
code O
give O
you O
null O
pointer O
exception O
. O

Student.getId O
Because O
you O
are O
using O
Obj_Student O
but O
you O
forgot O
to O
initialize O
it O
like O
wise O
correct O
code O
is O
shown O
below O
Student O
Student.setId O
Student.getId O

Another O
occurrence O
of O
a O
NullPointerException O
occurs O
when O
one O
declares O
an O
object O
array O
, O
then O
immediately O
tries O
to O
dereference O
elements O
inside O
of O
it O
. O

String.equals O
This O
particular O
NPE O
can O
be O
avoided O
if O
the O
comparison O
order O
is O
reversed O
; O
namely O
, O
use O
. O
equals O
on O
a O
guaranteed O
non-null O
object O
. O

All O
elements O
inside O
of O
an O
array O
are O
initialized O
to O
their O
common O
initial O
value O
; O
for O
any O
type O
of O
object O
array O
, O
that O
means O
that O
all O
elements O
are O
null O
. O

You O
must O
initialize O
the O
elements O
in O
the O
array O
before O
accessing O
or O
derefencing O
them O
. O

String.equals O

What O
is O
a O
NullPointerException O
? O

A O
good O
place O
to O
start O
is O
the O
JavaDocs O
. O

They O
have O
this O
covered O
: O

Thrown O
when O
an O
application O
attempts O
to O
use O
null O
in O
a O
case O
where O
an O
object O
is O
required O
. O

These O
include O
: O
Calling O
the O
instance O
method O
of O
a O
null O
object O
. O

Accessing O
or O
modifying O
the O
field O
of O
a O
null O
object O
. O

Taking O
the O
length O
of O
null O
as O
if O
it O
were O
an O
array O
. O

Accessing O
or O
modifying O
the O
slots O
of O
null O
as O
if O
it O
were O
an O
array O
. O

Throwing O
null O
as O
if O
it O
were O
a O
Throwable O
value O
. O

Applications O
should O
throw O
instances O
of O
this O
class O
to O
indicate O
other O
illegal O
uses O
of O
the O
null O
object O
. O

It O
is O
also O
the O
case O
that O
if O
you O
attempt O
to O
use O
a O
null O
reference O
with O
synchronized O
, O
that O
will O
also O
throw O
this O
exception O
, O
per O
the O
JLS O
: O

Otherwise O
, O
if O
the O
value O
of O
the O
Expression O
is O
null O
, O
a O
NullPointerException O
is O
thrown O
. O

How O
do O
I O
fix O
it O
? O

So O
you O
have O
a O
NullPointerException O
, O
how O
do O
you O
fix O
it O
? O

Let's O
take O
a O
simple O
example O
which O
throws O
a O
NullPointerException O
Printer.printString O
String.length O
Printer O
Identify O
the O
null O
values O
The O
first O
step O
is O
identifying O
exactly O
which O
values O
are O
causing O
the O
exception O
. O

For O
this O
we O
need O
to O
do O
some O
debugging O
. O

It's O
important O
to O
learn O
to O
read O
a O
stacktrace O
. O

This O
will O
show O
you O
where O
the O
exception O
was O
thrown O
: O
Here O
, O
we O
see O
that O
the O
exception O
is O
thrown O
on O
line O
13 O
( O
in O
the O
printString O
method O
) O
. O

Look O
at O
line O
and O
check O
which O
values O
are O
null O
by O
adding O
logging O
statements O
or O
using O
a O
debugger O
. O

We O
find O
out O
that O
s O
is O
null O
, O
and O
calling O
the O
length O
method O
on O
it O
throws O
the O
exception O
. O

We O
can O
see O
that O
the O
program O
stops O
throwing O
the O
exception O
when O
s.length() O
is O
removed O
from O
the O
method O
. O

Trace O
where O
these O
values O
come O
from O
Next O
check O
where O
this O
value O
comes O
from O
. O

By O
following O
the O
callers O
of O
the O
method O
, O
we O
see O
that O
s O
is O
passed O
in O
with O
printString O
( O
name O
) O
in O
the O
print() O
method O
, O
and O
this.name O
is O
null O
. O

Trace O
where O
these O
values O
should O
be O
set O
Where O
is O
this.name O
set O
? O

In O
the O
setName O
( O
String O
) O
method O
. O

With O
some O
more O
debugging O
, O
we O
can O
see O
that O
this O
method O
isn't O
called O
at O
all O
. O

If O
the O
method O
was O
called O
, O
make O
sure O
to O
check O
the O
order O
that O
these O
methods O
are O
called O
, O
and O
the O
set O
method O
isn't O
called O
after O
the O
print O
method O
. O

This O
is O
enough O
to O
give O
us O
a O
solution O
: O
add O
a O
call O
to O
printer.setName() O
before O
calling O
printer.print() O
. O

Other O
fixes O
The O
variable O
can O
have O
a O
default O
value O
( O
and O
setName O
can O
prevent O
it O
being O
set O
to O
null O
): O

Either O
the O
print O
or O
printString O
method O
can O
check O
for O
null O
, O
for O
example O
: O
Or O
you O
can O
design O
the O
class O
so O
that O
name O
always O
has O
a O
non-null O
value O
: O
Printer.printString O
String.length O
Printer O
See O
also O
: O

Avoiding O
“ O
! O
= O

null O
” O
statements O
in O
Java O
? O

I O
still O
can't O
find O
the O
problem O
If O
you O
tried O
to O
debug O
the O
problem O
and O
still O
don't O
have O
a O
solution O
, O
you O
can O
post O
a O
question O
for O
more O
help O
, O
but O
make O
sure O
to O
include O
what O
you've O
tried O
so O
far O
. O

At O
a O
minimum O
, O
include O
the O
stacktrace O
in O
the O
question O
, O
and O
mark O
the O
important O
line O
numbers O
in O
the O
code O
. O

Also O
, O
try O
simplifying O
the O
code O
first O
( O
see O
SSCCE O
) O
. O

Question O
: O

What O
causes O
a O
NullPointerException O
? O

As O
you O
should O
know O
, O
Java O
types O
are O
divided O
into O
primitive O
types O
( O
boolean O
, O
int O
etc O
) O
and O
reference O
types O
. O

Reference O
types O
in O
Java O
allow O
you O
to O
use O
the O
special O
value O
null O
which O
is O
the O
Java O
way O
of O
saying O
" O
no O
object O
" O
. O

A O
NullPointerException O
is O
thrown O
at O
runtime O
whenever O
your O
program O
attempts O
to O
use O
a O
null O
as O
if O
it O
was O
a O
real O
reference O
. O

For O
example O
, O
if O
you O
write O
this O
: O
String.length O
HERE O
the O
statement O
labelled O
" O
HERE O
" O
is O
going O
to O
attempt O
to O
run O
the O
length() O
method O
on O
a O
null O
reference O
, O
and O
this O
will O
throw O
a O
NullPointerException O
. O

There O
are O
many O
ways O
that O
you O
could O
use O
a O
null O
value O
that O
will O
result O
in O
a O
NullPointerException O
. O

If O
fact O
, O
the O
only O
things O
that O
you O
can O
do O
with O
a O
null O
without O
causing O
an O
NPE O
are O
: O
assign O
it O
to O
a O
reference O
variable O
or O
read O
it O
from O
a O
reference O
variable O
, O
assign O
it O
to O
an O
array O
element O
or O
read O
it O
from O
an O
array O
element O
( O
provided O
that O
array O
reference O
itself O
is O
non-null O
! O
) O
, O
pass O
it O
as O
a O
parameter O
or O
return O
it O
as O
a O
result O
, O
or O
test O
it O
using O
the O
== O
or O
! O
= O

operators O
, O
or O
instanceof O
. O

Question O
: O

How O
do O
I O
read O
the O
NPE O
stacktrace O
? O

Suppose O
that O
I O
compile O
and O
run O
the O
program O
above O
: O
First O
observation O
: O
the O
compilation O
succeeds O
! O

The O
problem O
in O
the O
program O
is O
NOT O
a O
compilation O
error O
. O

It O
is O
a O
runtime O
error O
. O

( O
Some O
IDEs O
may O
warn O
your O
program O
will O
always O
throw O
an O
exception O
... O
but O
the O
standard O
javac O
compiler O
doesn't O
. O
) O

Second O
observation O
: O
when O
I O
run O
the O
program O
, O
it O
outputs O
two O
lines O
of O
" O
gobbledy-gook O
" O
. O

WRONG O
!! O

That's O
not O
gobbledy-gook O
. O

It O
is O
a O
stacktrace O
... O
and O
it O
provides O
vital O
information O
that O
will O
help O
you O
track O
down O
the O
error O
in O
your O
code O
, O
if O
you O
take O
the O
time O
to O
read O
it O
carefully O
. O

So O
lets O
look O
at O
what O
is O
says O
: O
The O
first O
line O
of O
the O
stack O
trace O
tells O
you O
a O
number O
of O
things O
: O
It O
tells O
you O
the O
name O
of O
the O
Java O
thread O
in O
which O
the O
exception O
was O
thrown O
. O

For O
a O
simple O
program O
with O
one O
thread O
( O
like O
this O
one O
) O
, O
it O
will O
be O
" O
main O
" O
. O

Lets O
move O
on O
... O

It O
tells O
you O
the O
full O
name O
of O
the O
exception O
that O
was O
thrown O
; O
i.e. O
java.lang.NullPointerException O
. O

If O
the O
exception O
has O
an O
associated O
error O
message O
, O
that O
will O
be O
output O
after O
the O
exception O
name O
. O

NullPointerException O
is O
unusual O
in O
this O
respect O
because O
it O
rarely O
has O
an O
error O
message O
. O

The O
second O
line O
is O
the O
most O
important O
one O
in O
diagnosing O
an O
NPE O
. O

This O
tells O
us O
a O
number O
of O
things O
: O
" O
at O
Test.main O
" O
says O
that O
we O
were O
in O
the O
main O
method O
of O
the O
Test O
class O
. O

" O
Test.java O
: O

4 O
" O
gives O
the O
source O
filename O
of O
the O
class O
, O
AND O
it O
tells O
us O
that O
the O
statement O
where O
this O
occurred O
is O
in O
line O
4 O
of O
the O
file O
. O

And O
if O
you O
count O
the O
lines O
in O
the O
file O
above O
, O
line O
4 O
is O
the O
one O
that O
I O
labelled O
with O
the O
" O
HERE O
" O
comment O
. O

Note O
that O
in O
a O
more O
complicated O
example O
, O
there O
will O
be O
lots O
of O
lines O
in O
the O
NPE O
stack O
trace O
. O

But O
you O
can O
be O
sure O
that O
the O
second O
line O
( O
the O
first O
" O
at O
" O
line O
) O
will O
tell O
you O
where O
the O
NPE O
was O
thrown1 O
. O

In O
short O
the O
stacktrace O
will O
tell O
us O
unambiguously O
which O
statement O
of O
the O
program O
has O
thrown O
the O
NPE O
. O

1 O
- O
Not O
quite O
true O
. O

There O
are O
things O
called O
nested O
exceptions O
... O

Question O
: O

How O
do O
I O
track O
down O
the O
cause O
of O
the O
NPE O
exception O
in O
my O
code O
? O

This O
is O
the O
hard O
part O
. O

The O
short O
answer O
is O
to O
apply O
logical O
inference O
to O
the O
evidence O
provided O
by O
the O
stack O
trace O
, O
the O
source O
code O
and O
the O
relevant O
API O
documentation O
. O

Lets O
illustrate O
with O
the O
simple O
example O
( O
above O
) O
first O
. O

We O
start O
by O
looking O
at O
the O
line O
that O
the O
stacktrace O
has O
told O
us O
is O
where O
the O
NPE O
happened O
: O

HERE O
How O
can O
that O
throw O
an O
NPE O
? O

In O
fact O
there O
is O
only O
one O
way O
: O
it O
can O
only O
happen O
if O
foo O
has O
the O
value O
null O
. O

We O
then O
try O
to O
run O
the O
length() O
method O
on O
null O
and O
.... O

BANG O
! O

But O
( O
I O
hear O
you O
say O
) O

what O
if O
the O
NPE O
was O
thrown O
inside O
the O
length() O
method O
call O
? O

Well O
if O
that O
happened O
, O
the O
stacktrace O
would O
look O
different O
. O

The O
first O
" O
at O
" O
line O
would O
say O
that O
the O
exception O
was O
thrown O
in O
some O
line O
in O
the O
java.lang.String O
class O
, O
and O
line O
4 O
of O
Test.java O
would O
be O
the O
second O
" O
at O
" O
line O
. O

So O
where O
did O
that O
null O
come O
from O
? O

In O
this O
case O
it O
is O
obvious O
and O
it O
is O
obvious O
what O
we O
need O
to O
do O
to O
fix O
it O
. O

( O
Assign O
a O
non-null O
value O
to O
foo O
) O
OK O
, O
so O
lets O
try O
a O
slightly O
more O
tricky O
example O
. O

This O
will O
require O
some O
logical O
deduction O
. O

So O
now O
we O
have O
2 O
" O
at O
" O
lines O
. O

The O
first O
one O
is O
for O
this O
line O
: O
and O
the O
second O
one O
is O
for O
this O
line O
: O

So O
looking O
at O
the O
first O
line O
, O
how O
could O
that O
throw O
an O
NPE O
? O

In O
fact O
, O
there O
are O
two O
ways O
: O
If O
the O
value O
of O
bar O
is O
null O
then O
bar[pos O
] O
will O
throw O
an O
NPE O
. O

If O
the O
value O
of O
bar[pos O
] O
is O
null O
then O
calling O
length() O
on O
it O
will O
throw O
an O
NPE O
. O

So O
next O
we O
need O
to O
figure O
out O
which O
of O
those O
scenarios O
explains O
what O
is O
actually O
happening O
. O

Lets O
start O
by O
exploring O
the O
first O
one O
: O
Where O
does O
bar O
come O
from O
? O

It O
is O
a O
parameter O
to O
the O
test O
method O
call O
, O
and O
if O
we O
look O
at O
how O
test O
was O
called O
, O
we O
can O
see O
that O
it O
comes O
from O
the O
foo O
static O
variable O
. O

And O
we O
can O
see O
clearly O
that O
we O
initialized O
foo O
to O
a O
non-null O
value O
. O

That O
is O
sufficient O
to O
tentatively O
dismiss O
this O
explanation O
. O

( O
In O
theory O
, O
something O
else O
could O
change O
foo O
to O
null O
... O
but O
that's O
not O
happening O
here O
. O
) O

So O
what O
about O
our O
2nd O
scenario O
? O

Well O
we O
can O
see O
that O
pos O
is O
1 O
, O
so O
that O
means O
that O
foo[1 O
] O
must O
be O
null O
. O

Is O
that O
possible O
? O

Indeed O
it O
is O
! O

And O
that O
is O
the O
problem O
. O

When O
we O
initialize O
like O
this O
: O
we O
allocate O
a O
String O
[] O
with O
two O
elements O
that O
are O
initialized O
to O
null O
. O

And O
then O
we O
didn't O
change O
the O
contents O
of O
foo O
... O

so O
foo[ O

1 O
] O
will O
still O
be O
null O
. O

A O
lot O
of O
explanations O
are O
already O
present O
to O
explain O
how O
it O
happens O
and O
how O
to O
fix O
it O
but O
you O
should O
also O
follow O
best O
practices O
to O
avoid O
NullPointerException O
at O
all O
. O

See O
also O
: O

A O
good O
list O
of O
best O
practices O
I O
would O
add O
, O
very O
important O
, O
make O
a O
good O
use O
of O
the O
final O
modifier O
. O

Using O
" O
final O
" O
modifier O
whenever O
applicable O
in O
java O
Summary O
: O

Use O
final O
modifier O
to O
enforce O
good O
initialization O
. O

Avoid O
returning O
null O
in O
methods O
, O
for O
example O
returning O
empty O
collections O
when O
applicable O
. O

Use O
annotations O
@NotNull O
and O
@Nullable O
Fail O
fast O
and O
use O
asserts O
to O
avoid O
propagation O
of O
null O
objects O
trough O
the O
whole O
application O
when O
they O
shouldn't O
be O
null O
. O

Use O
equals O
with O
known O
object O
first O
: O
if O
( O
" O
knownObject O
" O
. O

equals O
( O
unknownObject O
) O
Prefer O
valueOf() O
over O
toString() O
. O

Use O
null O
safe O
StringUtils O
methods O
StringUtils.isEmpty O
( O
null O
) O
. O

